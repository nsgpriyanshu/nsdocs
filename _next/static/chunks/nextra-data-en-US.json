{"/developer/advance":{"title":"Creating the Core","data":{"":"The index.ts file is the heart of your bot. It serves as the entry point for your application, initializing and configuring the bot to connect to Discord and start responding to events and commands.","project-structure#Project Structure":"Now, inside the src directory, add a file named index.ts.","creating-indexts#Creating index.ts":"This is the main file, or we can say the core file, of the bot.\nimport { Client, Collection, GatewayIntentBits } from 'discord.js'\nimport { ExtendedClient } from './interfaces/ExtendedClient'\nimport { logBrightPink } from 'nstypocolors'\nimport config from './configs/botConfig'\nimport { commandHandler } from './handlers/commandHandler'\nimport { eventHandlers } from './events/eventIndex'\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n  ],\n}) as ExtendedClient\nclient.slashCommands = new Collection()\nclient.messageCommands = new Collection()\nclient.events = new Collection()\ncommandHandler(client)\neventHandlers(client)\nclient\n  .login(config.BOT_TOKEN)\n  .then(() => logBrightPink('Successfully connected all the commands and the bot is online'))\n  .catch((err: string) => console.error('Failed to login: ' + err))\nFeel free to customize this setup to suit your needs. You can add additional intents,\nconfigurations, or other settings to enhance the functionality of your bot.","verification#Verification":"Ensure that you have imported everything correctly and that you have defined your client properly.","run#Run":"Now open your terminal and enter:\nnpm run execute\nCongratualations, finally your app (bot) is online.","live-example#Live Example":"Here is the live example of our Power Op app based on nsCore. You can add this app on your server!","thank-you#Thank You":"Dont forget to give a star in github."}},"/developer/advance/introduction":{"title":"Getting Ended","data":{"":"So yeah, this is the last part — just a little more work, and we're done. Let's get started!","project-structure#Project Structure":"Our final structure should look like this:","before-clicking-the-run-button#Before Clicking the Run Button":"Guys, we're finally done! Now, you just need to add the main entry file, index.ts, and you're ready to click the run button.I hope this guide has helped you build a production-level Discord bot. Remember, you can contribute to this guide, as it is open source. Thank you for using my guide. Happy coding and enjoy your journey with Discord bots!"}},"/developer/advance/scripts":{"title":"Scripts","data":{"":"Before moving to the index.ts file, ensure that you have configured your scripts properly in the package.json file.","creating-scripts#Creating scripts":"Now, in the package.json file, add these scripts:\n\"scripts\": {\n    \"test\": \"npx jest\",\n    \"clean\": \"rimraf dist types\",\n    \"build\": \"npx tsc\",\n    \"format:check\": \"npx prettier . --check\",\n    \"format:write\": \"npx prettier . --write\",\n    \"deploy\": \"node dist/utils/deployCommands.js\",\n    \"start\": \"node dist/index.js\",\n    \"execute\": \"npm run clean && npm run build && npm run format:write && npm run start\",\n    \"cleanStart\": \"npm run clean && npm run build && npm run start\",\n    \"noCleanStart\": \"npm run build && npm run start\",\n    \"lint\": \"eslint 'src/**/*.{ts,tsx}'\",\n    \"lint:fix\": \"eslint 'src/**/*.{ts,tsx}' --fix\"\n  },\nYou can add more scripts as needed.\nAlright, let's move to the last part."}},"/developer/codeFormatters":{"title":"Codeformatters","data":{"code-formatting#Code Formatting":"Now let's set up our code formatting styles by using some popular libraries!","installing-prettier#Installing Prettier":"This is a very popular code formatting library. Here are the required configurations for our Discord app project!\nnpm install --save-dev --save-exact prettier\nThen, create an empty config file to let editors and other tools know you are using Prettier:\nnode --eval \"fs.writeFileSync('.prettierrc','{}\\n')\"\nNow, add this configurations:\n{\n  \"printWidth\": 100,\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"all\",\n  \"tabWidth\": 2,\n  \"useTabs\": false,\n  \"arrowParens\": \"avoid\"\n}\nYou can add more formatting configurations like this!","installing-eslint#Installing Eslint":"ESLint is also a very good library, so we will use this library too! Here are the ESLint configurations as per Discord.js!\nnpm install --save-dev eslint\nNow, create .eslintrc and add your rules:\nnsCore config.\n{\n  \"env\": {\n    \"browser\": false,\n     \"node\": true,\n     \"es2021\": true\n  },\n   \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n   },\n   \"plugins\": [\"@typescript-eslint\"],\n   \"extends\": [\n     \"eslint:recommended\",\n   ],\n  \"rules\": {\n    \"no-console\": \"off\"\n   }\n }\ndiscord.js config.\n{\n\"extends\": \"eslint:recommended\",\n\"env\": {\n  \"node\": true,\n  \"es6\": true\n},\n\"parserOptions\": {\n  \"ecmaVersion\": 2021\n},\n\"rules\": {\n  \"arrow-spacing\": [\"warn\", { \"before\": true, \"after\": true }],\n  \"brace-style\": [\"error\", \"stroustrup\", { \"allowSingleLine\": true }],\n  \"comma-dangle\": [\"error\", \"always-multiline\"],\n  \"comma-spacing\": \"error\",\n  \"comma-style\": \"error\",\n  \"curly\": [\"error\", \"multi-line\", \"consistent\"],\n  \"dot-location\": [\"error\", \"property\"],\n  \"handle-callback-err\": \"off\",\n  \"indent\": [\"error\", \"tab\"],\n  \"keyword-spacing\": \"error\",\n  \"max-nested-callbacks\": [\"error\", { \"max\": 4 }],\n  \"max-statements-per-line\": [\"error\", { \"max\": 2 }],\n  \"no-console\": \"off\",\n  \"no-empty-function\": \"error\",\n  \"no-floating-decimal\": \"error\",\n  \"no-inline-comments\": \"error\",\n  \"no-lonely-if\": \"error\",\n  \"no-multi-spaces\": \"error\",\n  \"no-multiple-empty-lines\": [\"error\", { \"max\": 2, \"maxEOF\": 1, \"maxBOF\": 0 }],\n  \"no-shadow\": [\"error\", { \"allow\": [\"err\", \"resolve\", \"reject\"] }],\n  \"no-trailing-spaces\": [\"error\"],\n  \"no-var\": \"error\",\n  \"object-curly-spacing\": [\"error\", \"always\"],\n  \"prefer-const\": \"error\",\n  \"quotes\": [\"error\", \"single\"],\n  \"semi\": [\"error\", \"always\"],\n  \"space-before-blocks\": \"error\",\n  \"space-before-function-paren\": [\"error\", {\n  \t\"anonymous\": \"never\",\n  \t\"named\": \"never\",\n  \t\"asyncArrow\": \"always\"\n  }],\n  \"space-in-parens\": \"error\",\n  \"space-infix-ops\": \"error\",\n  \"space-unary-ops\": \"error\",\n  \"spaced-comment\": \"error\",\n  \"yoda\": \"error\"\n}\n}","plugings#Plugings":"Since we are using ESLint with Prettier, it's beneficial to use a plugin for better integration. To set up plugins, install the necessary dependencies first:\nnpm i eslint-plugin-prettier\nAdd the Prettier plugin to your ESLint configuration in .eslintrc:\n{\n  \"env\": {\n    \"browser\": false,\n    \"node\": true,\n    \"es2021\": true\n  },\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\"@typescript-eslint\"],\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n    \"plugin:node/recommended\",\n    \"prettier\"\n  ],\n  \"rules\": {\n    \"no-console\": \"off\",\n    \"node/no-unsupported-features/es-syntax\": [\n      \"error\",\n      {\n        \"ignores\": [\"modules\"]\n      }\n    ],\n    \"@typescript-eslint/no-unused-vars\": [\"error\", { \"argsIgnorePattern\": \"^_\" }],\n    \"@typescript-eslint/explicit-module-boundary-types\": \"off\",\n    \"@typescript-eslint/no-explicit-any\": \"off\",\n    \"@typescript-eslint/ban-ts-comment\": \"off\"\n  }\n}\nYou can find a list of all of ESLint's rules on their\nwebsite.\nThis configuration extends the core vitals for the app and includes the recommended settings for Prettier, ensuring that ESLint and Prettier work together seamlessly.Alright, we're all set! Now we can proceed further."}},"/developer/commandSetup":{"title":"Getting Started","data":{"":"In a Discord bot, commands are instructions given by users to the bot to perform specific actions or tasks. These commands can be typed directly into the chat by users, triggering the bot to execute a predefined function. Commands are a fundamental part of bot interaction, enabling users to control the bot and retrieve information or perform actions within a server. There are primarily two types of commands: message commands and slash commands.","project-structure#Project Structure":"To organize your commands efficiently, we'll set up a structured project directory. This helps in maintaining a clean codebase and makes it easier to manage different types of commands.","command-types#Command Types":"Our app supports both types of commands:\nMessage Commands: These are traditional commands that users type in chat, usually prefixed with a character like ! or ?. For example, !help or !ping.\nSlash Commands: These are the newer type of commands introduced by Discord. Users can type / followed by the command name, and Discord will present an interface to help users complete the command. Its also known as Interaction Command\nNow let's move ahead!"}},"/developer/commandSetup/messageCommands":{"title":"Message Commands","data":{"":"Message commands are traditional commands in Discord bots that users type directly into the chat. These commands are typically prefixed with a specific character (like !, ?, or any custom prefix you choose). When the bot detects a message starting with this prefix, it processes the command and executes the corresponding function. Message commands are straightforward and easy to use, making them a popular choice for many bot functionalities.","project-structure#Project Structure":"First, create a folder named commands inside the src folder. Then, inside the commands folder, create another folder named messageCommands. Inside this messageCommands folder, create a folder named general. Finally, inside the general folder, add a file named ping.ts\nOur message command structure is organized into subdirectories, allowing for better code\nmanagement and customization.","create-ping-command#Create Ping Command":"Let's create a basic ping command to demonstrate how message commands work. This command will respond with \"Pong!\" when a user types !ping.\nimport { EmbedBuilder, Message } from 'discord.js'\nimport { COLORS, EMOJIS } from '../../../constants/botConst'\nimport { MessageCommand } from '../../../interfaces/Command'\nconst ping: MessageCommand = {\n  name: 'ping',\n  description: 'Replies with Ping!',\n  async executeMessage(message: Message) {\n    const pingEmbed = new EmbedBuilder()\n      .setColor(COLORS.green)\n      .setTitle('ping Command')\n      .setDescription(`${EMOJIS.success} Ping pong ping`)\n    await message.channel.send({ embeds: [pingEmbed] })\n  },\n  userPermissions: ['SendMessages'],\n  botPermissions: ['SendMessages'],\n  devOnly: false,\n}\nexport default ping\nFor example purposes, I have used this ! prefix. However, in reality, this configuration comes\ninto effect whenever the prefix is enabled. Remember, we have already set up our prefix inside\nthe messageCreate event file inside the events\nfolder, so now all these components are interconnected. We have imported constants from the\nconstants folder and interfaces from the interfaces folder. Ensure that all the imports are\ncorrect and properly configured.","message-command-structure#Message Command Structure":"Now here are the example of the command structure make sure all of your message command will follow this structure.\nimport { EmbedBuilder, Message } from 'discord.js'\nimport { COLORS, EMOJIS } from '../../../constants/botConst'\nimport { MessageCommand } from '../../../interfaces/Command'\nconst string: MessageCommand = {\n  name: string,\n  description: string,\n  async executeMessage(message: Message) {\n    const stringEmbed = new EmbedBuilder()\n      .setColor(COLORS.name)\n      .setTitle(string)\n      .setDescription(string)\n    await message.channel.send({ embeds: [string] })\n  },\n  userPermissions: [''],\n  botPermissions: [''],\n  devOnly: false / true,\n}\nexport default string\nNow, in the blank spaces, you can add whatever you want. Feel free to modify this command\nstructure to suit your needs.","developer-command#Developer Command":"The Developer Command is a type of command that is restricted to developers only. To enable a command as a Developer Command, you simply need to set the devOnly property to true.\nAlright, now let's go further!"}},"/developer/commandSetup/slashCommands":{"title":"Slash Commands","data":{"":"Slash commands, also known as interaction commands, are a newer feature introduced by Discord that provide a more streamlined and user-friendly way for users to interact with bots. Unlike message commands, slash commands are invoked by typing / followed by the command name directly into the chat input box.","project-structure#Project Structure":"Now that we've already created the commands folder, let's add a folder named slashCommands inside it. Then, within the slashCommands folder, add another folder named general. Finally, inside the general folder, add ping.ts.\nOur slash command structure is organized similarly to message commands, allowing for efficient\ncode management and customization.","create-ping-command#Create Ping Command":"Let's create a basic ping slash command to demonstrate how slash commands work. This command will respond with \"Pong!\" when invoked by the user.\nimport { CommandInteraction, EmbedBuilder, SlashCommandBuilder } from 'discord.js'\nimport { COLORS, EMOJIS } from '../../../constants/botConst'\nimport { SlashCommand } from '../../../interfaces/Command'\nconst Ping: SlashCommand = {\n  name: 'ping',\n  description: 'Replies with pong!',\n  data: new SlashCommandBuilder().setName('pong').setDescription('Replies with pong!'),\n  async executeSlash(interaction: CommandInteraction) {\n    const pEmbed = new EmbedBuilder()\n      .setColor(COLORS.green)\n      .setTitle('ping Command')\n      .setDescription(`${EMOJIS.success} pong there, I am Ping`)\n    await interaction.reply({ embeds: [PingEmbed] })\n  },\n  userPermissions: ['SendMessages'],\n  botPermissions: ['SendMessages'],\n  devOnly: false,\n}\nexport default Ping\nSlash command with 100% potential is under development this structure is come with 90% potential\nonly. We are trying our best to acquire the 10% potential also.","slash-command-structure#Slash Command Structure":"Here is an example of the structure of a slash command:\nimport { CommandInteraction, EmbedBuilder, SlashCommandBuilder } from 'discord.js'\nimport { COLORS, EMOJIS } from '../../../constants/botConst'\nimport { SlashCommand } from '../../../interfaces/Command'\nconst string: SlashCommand = {\n  name: string,\n  description: string',\n  data: new SlashCommandBuilder().setName(string).setDescription(string),\n  async executeSlash(interaction: CommandInteraction) {\n    const stringEmbed = new EmbedBuilder()\n      .setColor(COLORS.name)\n      .setTitle(string)\n      .setDescription(string)\n    await interaction.reply({ embeds: [string] })\n  },\n  userPermissions: [''],\n  botPermissions: [''],\n  devOnly: false/true,\n}\nexport default string\nWe did not include any type of developer commands in Slash Commands. However, our command\nhandler and event handler are well-structured and capable of handling both regular and\ndeveloper commands. If you want to include a developer command in Slash Commands, you simply\nneed to set the devOnly property to true. There's no need to add anything extra because our\nhandlers are perfectly equipped to handle it.\nAlright! Go go ahead."}},"/developer/config&const":{"title":"Getting Started","data":{"":"So, we've mostly completed all our work outside the src directory. Now it's time to enter the src directory, where things will get a bit more complex. It's better to begin with the blueprint of the project structure!","project-structure#Project Structure":"Here is the basic project structure that nsCore will look like:\nnsCore/\n├── node_modules/\n├── src/\n├── .env\n├── .eslintrc\n├── .eslintignore\n├── .prettierrc\n├── .prettierignore\n├── .gitignore\n├── package.json\n├── package-lock.json\n├── tsconfig.json\nNow we have to create each folder and component separately, so let's begin!"}},"/developer/eventSetup/centralize":{"title":"Centralize Handler","data":{"":"Now, we have to create a entralized function, to export and import our events, this makes a better and easier way to export events.","project-structure#Project Structure":"Add an eventIndex.ts file inside the event folder.","add-eventindexts#Add eventIndex.ts":"This is our centralize handler code:\nimport { registerReadyEvent } from './client/ready'\nimport { eventHandlerInteraction } from './client/interactionCreate'\nimport { eventHandlerMessage } from './client/messageCreate'\nimport { ExtendedClient } from '../interfaces/ExtendedClient'\nexport function eventHandlers(client: ExtendedClient) {\n  registerReadyEvent(client)\n  eventHandlerInteraction(client)\n  eventHandlerMessage(client)\n}\nYou can add more functions like this to centralize event handling.","verification#Verification":"Ensure you have imported everything correctly.\nAlright, lets move ahead,"}},"/developer/eventSetup":{"title":"Introduction","data":{"":"This section will cover the event handling part, which is a fundamental concept of a Discord bot.","project-structure#Project Structure":"To efficiently handle events in our Discord bot, we'll structure our project in a way that separates different responsibilities. Below is an example project structure focusing on event handling:","type-of-events#Type of events":"Discord has various types of events; however, the main three events required to run an app are:\nready event\nmessageCreate event\ninteractionCreate event\nYou can learn about more events from discord.js\nevents.\nNow let's understand these events one by one! So, let's go!"}},"/developer/gettingStarted":{"title":"Getting Started","data":{"":"Lets dive into the ocean of discord app development.","installation#Installation":"To install Node.js, visit the official  Node.js  website and download the installer for your operating system. Follow the installation instructions provided by the installer.Once Node.js is installed, you'll have access to npm, which is used to install packages and manage dependencies for your Node.js projects.","initiating-a-project-folder#Initiating a Project Folder":"To initiate a new project folder, open your terminal or command prompt and navigate to the directory where you want to create your project. Then, run the following command:\nmkdir nscore\ncd nscore\nI am not including the steps to create a Discord app (bot) or setting up Node.js. If you are\nunfamiliar with these processes, please refer to the Discord.js\ndocumentation.","installation-1#Installation":"Now, let's install Discord.js, which is a powerful library for interacting with the Discord API.\nnpm install discord.js\nThis command will download and install Discord.js and all its dependencies into your project folder. Once the installation is complete, you're ready to start building your Discord bot using Discord.js!All set! Now we are ready to go further!"}},"/developer/handlerSetup/error":{"title":"Error Handler","data":{"":"An error handler in a Discord bot is essential for managing and responding to errors that occur during the bot's operation. This includes handling exceptions that may arise from command execution, API calls, or other unexpected events. An effective error handler helps in maintaining the stability and reliability of the bot by gracefully managing errors and providing useful feedback to users and developers.","project-structure#Project Structure":"Add errorHandler.ts inside the handlers folder.","create-errorhandlerts#Create errorHandler.ts":"This file will contain the logic of the error handler, ensuring that any errors encountered during the bot's execution are properly managed and logged.\nimport { Client, EmbedBuilder, TextChannel } from 'discord.js'\nimport config from '../configs/botConfig'\nimport { COLORS, EMOJIS } from '../constants/botConst'\nconst errorHandler = (client: Client) => {\n  const errorChannelId = config.ERROR_CHANNEL\n  const sendErrorEmbed = async (title: string, description: string) => {\n    const errorChannel = client.channels.cache.get(errorChannelId) as TextChannel\n    if (errorChannel) {\n      const errorEmbed = new EmbedBuilder()\n        .setTitle(title)\n        .setDescription(description)\n        .setColor(COLORS.red)\n        .setTimestamp()\n      await errorChannel.send({ embeds: [errorEmbed] })\n    }\n  }\n  process.on('unhandledRejection', (reason, p) => {\n    console.log('[ERROR-HANDLING] :: Unhandled Rejection/Catch')\n    console.log(reason, p)\n    sendErrorEmbed(\n      `${EMOJIS.failed} New Error (Error type 1)`,\n      `An error just occurred in the bot console! **\\n\\nERROR:\\n\\n** \\`\\`\\`${reason}\\n\\n${p}\\`\\`\\``,\n    )\n  })\n  process.on('uncaughtException', (err, origin) => {\n    console.log('[ERROR-HANDLING] :: Unhandled Exception/Catch')\n    console.log(err, origin)\n    sendErrorEmbed(\n      `${EMOJIS.failed} New Error (Error type 2)`,\n      `An error just occurred in the bot console! **\\n\\nERROR:\\n\\n** \\`\\`\\`${err}\\n\\n${origin}\\`\\`\\``,\n    )\n  })\n  process.on('uncaughtExceptionMonitor', (err, origin) => {\n    console.log('[ERROR-HANDLING] :: Unhandled Exception/Catch (MONITOR)')\n    console.log(err, origin)\n    sendErrorEmbed(\n      `${EMOJIS.failed} New Error (Error type 3)`,\n      `An error just occurred in the bot console! **\\n\\nERROR:\\n\\n** \\`\\`\\`${err}\\n\\n${origin}\\`\\`\\``,\n    )\n  })\n}\nexport default errorHandler\nPlease ensure to include your error channel ID in your\n.env file (preferred) or config.ts file.\nAlright, we have completed more than half now let's go further!"}},"/developer/handlerSetup":{"title":"Introduction","data":{"":"Handlers in a Discord bot are essential components that manage different aspects of the bot's functionality. They are responsible for organizing and processing specific types of events or actions, such as commands, errors, and other interactions. By using handlers, you can keep your code modular, clean, and maintainable. Handlers help in separating different concerns, making the bot easier to debug, extend, and manage.","project-structure#Project Structure":"An overview of our project structure","types#Types":"For this project, we are going to use:\ncommandHandler for handling commands\nerrorHandler for handling errors\nSo, let's go!"}},"/developer/ignoringFiles":{"title":"Ignoring Files","data":{"":"It's time to create the necessary ignore files to prevent certain files from being uploaded to GitHub!","git-ignore#Git Ignore":"Let's create a .gitignore file:\n# Node.js\nnode_modules/\ndist/\n# TypeScript\n*.tsbuildinfo\n# Logs\n*.log\n# Testing and coverage\ncoverage/\n*.test.js\n# IDE-specific files\n.vscode/\n.idea/\n*.sublime-project\n*.sublime-workspace\n# OS-specific files\n.DS_Store\nThumbs.db\nehthumbs.db\ndesktop.ini\n# Environment variables\n.env\n# Miscellaneous\n!.gitignore\nDon't forget to include your .env file.","prettier-ignore#Prettier Ignore":"Let's create a .prettierignore file:\n# Ignore artifacts:\nbuild\ncoverage\nnode_modules\n.next","eslint-ignore#Eslint Ignore":"Also, its better to keep an .eslintignore file:\n# Ignore artifacts:\nbuild/\ncoverage/\nnode_modules/\n# Ignore specific files:\ndist/\nAlright, we have successfully created our ignore files. Now we can go ahead!"}},"/developer/interfaceSetup/command":{"title":"Command Interface","data":{"":"The Command Interface is a structure that defines how commands should be organized and managed within your Discord bot. By creating a command interface, you ensure that each command follows a consistent format, making it easier to manage and execute commands. This can include defining properties like the command name, description, execute function, and any required permissions.","project-structure#Project Structure":"As you know we already have created the interfaces folder so now just add Command.ts inside the interfaces folder.","create-commandinterfacets#Create CommandInterface.ts":"Defining a command interface helps ensure consistency and ease of management for all commands.\nimport {\n  ChatInputCommandInteraction,\n  Message,\n  PermissionResolvable,\n  SlashCommandSubcommandsOnlyBuilder,\n} from 'discord.js'\nimport { SlashCommandBuilder } from '@discordjs/builders'\nimport { ExtendedClient } from './ExtendedClient'\nexport interface SlashCommand {\n  name: string\n  description?: string\n  data:\n    | SlashCommandBuilder\n    | Omit<SlashCommandBuilder, 'addSubcommand' | 'addSubcommandGroup'>\n    | SlashCommandSubcommandsOnlyBuilder\n  executeSlash: (interaction: ChatInputCommandInteraction, client: ExtendedClient) => Promise<void>\n  userPermissions?: PermissionResolvable[]\n  botPermissions?: PermissionResolvable[]\n  devOnly?: boolean\n}\nexport interface MessageCommand {\n  name: string\n  description?: string\n  executeMessage: (message: Message, args: string[], client: ExtendedClient) => Promise<void>\n  userPermissions?: PermissionResolvable[]\n  botPermissions?: PermissionResolvable[]\n  devOnly?: boolean\n}\nexport interface Command extends SlashCommand, MessageCommand {}\nEnsure that all commands adhere to the defined interface for smooth operation.\nAlright, now let's move ahead!"}},"/developer/interfaceSetup/extendedClient":{"title":"Extended Client","data":{"":"The Extended Client refers to an enhanced version of the standard Discord client provided by the discord.js library. By extending the base client, we can add custom properties and methods that are specific to our bot's needs. This could include additional configurations, utility functions, or other custom features that the standard client does not provide.","project-structure#Project Structure":"First, create a folder named interfaces inside the src directory. Inside this interfaces folder, create a file named ExtendedClient.ts. This files will hold the constants for your project.","create-extendedclientts#Create ExtendedClient.ts":"You can extend your client as you want!\nimport { Client, Collection } from 'discord.js'\nimport { Command } from './Command'\nexport interface ExtendedClient extends Client {\n  events: Collection<string, (...args: any[]) => void>\n  messageCommands: Collection<string, Command>\n  slashCommands: Collection<string, Command>\n}\nAlright, now let's move ahead!"}},"/developer/interfaceSetup":{"title":"Getting Started","data":{"":"Let's start creating our interfaces!Interfaces in TypeScript define the structure of an object. They specify the types and the properties that an object should have. For a Discord bot, interfaces can help ensure that the objects we use, such as configurations, commands, and clients, adhere to the expected structure, which can prevent errors and improve code quality.","project-structure#Project Structure":"","necessary-interfaces#Necessary Interfaces":"For this project we will use only:\nExtendedClient interface\nCommand interface\nYou can setup more interfaces as of your need.\nNow we can go ahead!"}},"/developer/settings":{"title":"Settings","data":{"":"In this part, we will add our environmental variables and TypeScript configurations!","setting-up-tsconfigjson#Setting up tsconfig.json":"Now we have to set up the TypeScript configuration for compiling our TypeScript code into JavaScript!\n{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"resolveJsonModule\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"sourceMap\": true,\n    \"declaration\": true,\n    \"declarationDir\": \"./types\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\nYou can add more compiler options from here","setting-up-env#Setting up .env":"Now, this part is very crucial. Here we will set up our environmental variables, such as the app ID, client ID, etc.\nNever include your .env variables to public, Make sure you have put this on your git ignore\nfile.\nSo here is the setup needed for our Discord app project!Fisrt install dotenv\nnpm i dotenv\nThen add an .env file out of your src directory!\n   AUTH_TOKEN=YOUR-DISCORD-BOT-TOKEN\n   CLIENT_ID=YOUR-DISCORD-BOT-ID\n   DEVELOPER_IDS=YOUR-DISCORD-ID\n   SERVER_ID=YOUR-DEV-SERVER-ID\n   ERROR_CHANNEL_ID=YOUR-ERROR-CHANNEL-ID\nOkay, now our basic configuration setup is done!"}},"/developer/utilSetup/deployCommand":{"title":"Deploy Function","data":{"":"The deploy function in a Discord bot is crucial for registering and updating slash commands with Discord's API. This function ensures that the bot's commands are correctly deployed to either a specific server (guild) or globally across all servers. By using a deploy function, you can dynamically manage and update the bot's commands without manually configuring each command.","project-structure#Project Structure":"Now, simply add a deploy.ts file inside the utils folder.","creating-deployts#Creating deploy.ts":"Here is the logic for the deploy function:\nimport { REST, Routes, SlashCommandBuilder } from 'discord.js'\nimport { readdirSync, statSync } from 'fs'\nimport { join, extname } from 'path'\nimport { logger } from './logger'\nimport config from '../configs/botConfig'\ninterface SlashCommandJSON {\n  name: string\n  description: string\n  options?: Array<any>\n}\nconst includeDirectories = ['commands/slashCommands/general', 'commands/slashCommands/info']\nconst loadSlashCommands = (dirs: string[]): Promise<SlashCommandJSON[]> => {\n  return new Promise((resolve, reject) => {\n    const commands: SlashCommandJSON[] = []\n    const loadCommandsFromDir = async (dir: string) => {\n      const files = readdirSync(dir)\n      for (const file of files) {\n        const filePath = join(dir, file)\n        const fileStat = statSync(filePath)\n        if (fileStat.isDirectory()) {\n          await loadCommandsFromDir(filePath)\n        } else if (extname(file) === '.ts' || extname(file) === '.js') {\n          const commandModule = await import(filePath)\n          const command = commandModule.default\n          if (command && command.data instanceof SlashCommandBuilder) {\n            commands.push(command.data.toJSON())\n          }\n        }\n      }\n    }\n    Promise.all(dirs.map(dir => loadCommandsFromDir(dir)))\n      .then(() => resolve(commands))\n      .catch(reject)\n  })\n}\nconst absoluteIncludeDirectories = includeDirectories.map(dir => join(__dirname, '../', dir))\nloadSlashCommands(absoluteIncludeDirectories)\n  .then(commands => {\n    const rest = new REST({ version: '10' }).setToken(config.BOT_TOKEN!)\n    logger.log('Started refreshing application (/) commands.')\n    return rest.put(Routes.applicationCommands(config.BOT_ID!), { body: commands })\n  })\n  .then(() => {\n    logger.log('Successfully reloaded application (/) commands.')\n  })\n  .catch(error => {\n    if (error instanceof Error) {\n      logger.error(`Error registering commands: ${error.message}`)\n    } else {\n      logger.error('Unknown error occurred while registering commands.')\n    }\n  })\nIn case of any error, please contact with me in my discord server","ensuring-env#Ensuring .env":"Ensure that your CLIENT_ID and SERVER_ID are correctly set in your .env file.Finally, we have successfully completed our utility functions."}},"/developer/utilSetup":{"title":"Getting Started","data":{"":"Utilities, or utils, are helper functions and reusable code snippets that make development easier by providing common functionality that can be used throughout the project. These can include functions for logging, data processing, formatting, and other repetitive tasks.","project-structure#Project Structure":"An overview of our project structure\nAlright, let's begin!"}},"/":{"title":"Introducing nsDocs","data":{"":"Hey there, fellow creative developers! Welcome to the developer section of the nsCore app! I hope this guide will enhance your Discord app (bot) knowledge. So let's begin.","before-we-begin#Before We Begin":"If you don't know about TypeScript or JavaScript basics, please learn them first! At least, watch a one-shot video about them. Here I am leaving some links to some good YouTube channels. This is not sponsored by them!","best-for-learning-typescript#Best for learning TypeScript":"Complete Typescript in under 5 hours - Hitesh Choudhary\nTypeScript Tutorial for Beginners - Programming with Mosh\nLearn TypeScript in 50 Minutes - Academind\nTypeScript for Beginners - freeCodeCamp.org","best-for-learning-javascript#Best for learning JavaScript":"Javascript for beginners | chai aur #javascript - Chai aur Code\nIntroduction to JavaScript + Setup | JavaScript Tutorial in Hindi #1 - CodeWithHarry\nLearn JavaScript - Full Course for Beginners - freeCodeCamp.org\nJavaScript Full Course (2024) - Beginners to Pro - Shradha Khapra\nPlease note, now in\nDiscord\nbots are now referred to as apps. In this documentation, I have mentioned \"app\" (also referred to\nas \"bot\" in parentheses) so readers can understand.","quick-links#Quick links":"","thank-you#Thank You":"Thank you for believing in us and using our guide! I hope this will help you in your coding journey. Happy coding!"}},"/developer/config&const/constSetup":{"title":"Setting up Constants","data":{"":"In this section we will set our necessary const. so lets begin.","project-structure#Project Structure":"First, create a folder named constants inside the src directory. Inside this constants folder, create a file named botConst.ts. This files will hold the constants for your project.","adding-colors#Adding Colors":"Now we will add our colors for our app, this are the default colors for our app.In the botConst.ts file, we will add our colors:\nimport { ColorResolvable } from 'discord.js'\nexport const COLORS: { [key: string]: ColorResolvable } = {\n  red: '#ff3b30',\n  orange: '#ff9500',\n  yellow: '#ffcc00',\n  green: '#34c759',\n  mint: '#00c7be',\n  teal: '#30b0c7',\n  cyan: '#32ade6',\n  blue: '#007aff',\n  indigo: '#5856d6',\n  purple: '#af52de',\n  pink: '#ff2d55',\n  brown: '#a2845e',\n  lightGray: '#aeaeb2',\n  lightGrayMid: '#3a3a3c',\n  grayMid: '#2c2c2e',\n  darkGray: '#1c1c1e',\n} as const\nDone, now lets add emojis.","adding-emojis#Adding Emojis":"Now we will add our emojis, in the same file i.e botConst.ts add the emoji constants also:\nListen carefully: These emojis are specially created by nsCore Developers for the nsCore\napp. These emojis follow the color theme of the above colors. We highly suggest you use the same\nemojis that nsCore uses.\nexport const EMOJIS = {\n  success: '<:success:1242828455964315750>',\n  failed: '<:failed:1242828548297719898>',\n  caution: '<:caution:1242828667718209637>',\n  info: '<:info:1242828626311774320>',\n  seen: '<:seen:1242828705768935575>',\n  slash: '<:slash:1242828744171982900>',\n  ts: '<:ts:1244152291364176002>',\n  js: '<:js:1244152318207856672>',\n  apps: '<:apps:1244153325075697724>',\n  link: '<:links:1244153412199649300>',\n  devlopers: '<:developers:1244271269701091480>',\n  github: '<:github:1244270608754278463>',\n  leaf: '<:leaf:1244270440701100093>',\n  sparkles: '<:pearls:1244270698080501770>',\n  sparklesd: '<:pearlsd:1244270768599339028>',\n  vscode: '<:vscode:1244270888757629111>',\n  bugs: '<:bugs:1244270990620627034>',\n  message: '<:message:1244271071511838801>',\n  id: '<:id:1244271770618564740>',\n  inbox: '<:inbox:1244271719003193424>',\n  colors: '<:colors:1244271646278422649>',\n  members: '<:members:1244271591785758801>',\n  home: '<:home:1244271538849579058>',\n  globe: '<:globe:1244271487112970291>',\n  creators: '<:creators:1244271212582928404>',\n  heat: '<:heat:1244316740330979360>',\n  permissions: '<:permissions:1244316852562427934>',\n  tips: '<:tips:1244316790922678414>',\n  username: '<:username:1244531006711664712>',\n  server: '<:serverd:1244600141835403345>',\n  channel: '<:channel:1244649126788988929>',\n  badges: '<:badges:1244649060015673356>',\n  seo: '<:seo:1244532163484057700>',\n  crown: '<:crown:1244600088492507218>',\n  fun: '<:fun:1244650971389235293>',\n  roles: '<:roles:1244994437071896714>',\n  al: '<:al:1245751475532070922>',\n  ar: '<:ar:1245751409014472735>',\n} as const\nYou can use your own emojis, and if you wanted to use nsCore emojis, then contact with them in\ntheir server, here is the link.\nsuccessfully completed our constant section also, Now we can move ahead."}},"/developer/config&const/configSetup":{"title":"Setting up Configurations","data":{"":"In this section we will configure our necessary configurations. so lets begin.","project-structure#Project Structure":"First, create a folder named configs inside the src directory. Inside this configs folder, create a file named botConfig.ts and metadata.ts. This files will hold the configuration settings for your project.","adding-env-configurations#Adding .env Configurations":"Now, remember that we have created an .env file. We cannot implement this .env file directly into our project. Instead, we will use a configuration system to integrate these environment variables via our config file.\nYou can directly import your .env variables into your project, but it is a better approach to\nuse a configuration file. This provides a more reliable way to manage configurations and allows\nyou to define types, which is a main advantage of TypeScript.\nIn the botConfig.ts file, we will add our configurations:\nimport dotenv from 'dotenv'\ndotenv.config()\ninterface BotConfig {\n  BOT_TOKEN: string\n  BOT_ID: string\n  SERVER_ID: string\n  DEVELOPER_IDS: string[]\n  ERROR_CHANNEL: string\n  GATE_CHANNEL: string\n}\nconst config: BotConfig = {\n  BOT_TOKEN: process.env.AUTH_TOKEN as string,\n  BOT_ID: process.env.CLIENT_ID as string,\n  SERVER_ID: process.env.SERVER_ID as string,\n  DEVELOPER_IDS: (process.env.DEVELOPER_IDS || '').split(','),\n  ERROR_CHANNEL: process.env.ERROR_CHANNEL_ID as string,\n  GATE_CHANNEL: process.env.JOIN_GATE_CHANNEL_ID as string,\n}\nexport default config\nThis setup will load the environment variables from the .env file and make them available throughout your project.","adding-metadata#Adding Metadata":"In the metadata.ts file, we will add our prefix and name:\nAdd your app name and app prefix.\nexport const BOT = {\n  PREFIX: 'ns.',\n  NAME: 'nsCore',\n}\nThis file will help us to store our metadatas, which will be required in future also, you can more\nmetadatas as of your need.\nDone, successfully we have setted our configurations, lets move ahead."}},"/developer/eventSetup/messageCreate":{"title":"Message Create Event","data":{"":"The messageCreate event in Discord.js is triggered whenever a new message is created in a text channel. This event is useful for building features such as command handling, automated responses, and various message-based interactions. By listening to this event, you can execute specific code whenever a user sends a message in your Discord server.","project-structure#Project Structure":"Now inside the client folder add our messageCreate.ts file","create-messagecreatets#Create messageCreate.ts":"Now, we have to write the logic for our message create event. This file will contain the logic that should be executed whenever a new message is created. Typically, you will check if the message starts with a command prefix and then execute the corresponding command.\nThis message event handler comes with developer commands, bot permissions, and user permission\nchecks built-in.\nimport { EmbedBuilder, Message, PermissionsBitField } from 'discord.js'\nimport { ExtendedClient } from '../../interfaces/ExtendedClient'\nimport { logger } from '../../utils/logger'\nimport { BOT } from '../../configs/metadata'\nimport config from '../../configs/botConfig'\nimport { COLORS } from '../../constants/botConst'\nimport { EMOJIS } from '../../constants/botConst'\nexport const eventHandlerMessage = (client: ExtendedClient) => {\n  client.on('messageCreate', async (message: Message) => {\n    if (message.author.bot || !message.guild) return\n    if (!message.content.startsWith(BOT.PREFIX)) return\n    const args = message.content.slice(BOT.PREFIX.length).trim().split(/ +/g)\n    const commandName = args.shift()?.toLowerCase()\n    if (!commandName) return\n    const command = client.messageCommands.get(commandName)\n    if (!command) {\n      logger.warn(`Command not found: ${commandName}`)\n      const unknownCommand = new EmbedBuilder()\n        .setColor(COLORS.red)\n        .setTitle(`You cannot use this command!`)\n        .setDescription(`${EMOJIS.failed} There is no command like this`)\n        .setTimestamp()\n      return message.reply({ embeds: [unknownCommand] })\n    }\n    if (\n      command.userPermissions &&\n      !message.member?.permissions.has(PermissionsBitField.resolve(command.userPermissions))\n    ) {\n      const userPermEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle(`You cannot use this command!`)\n        .setDescription(\n          `${EMOJIS.caution} You don't have the required permissions to use this command`,\n        )\n        .setTimestamp()\n      return message.reply({ embeds: [userPermEmbed] })\n    }\n    if (!client.user) {\n      logger.error('Client user is null')\n      return\n    }\n    if (\n      command.botPermissions &&\n      !message.guild.members.cache\n        .get(client.user.id)\n        ?.permissions.has(PermissionsBitField.resolve(command.botPermissions))\n    ) {\n      const botPermEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle(`I cannot use this command!`)\n        .setDescription(\n          `${EMOJIS.caution} I don't have the required permissions to run this command`,\n        )\n        .setTimestamp()\n      return message.reply({ embeds: [botPermEmbed] })\n    }\n    if (command.devOnly && !config.DEVELOPER_IDS.includes(message.author.id)) {\n      const devOnlyEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle(`You cannot use this command!`)\n        .setDescription(`${EMOJIS.caution} This command is only for developers`)\n        .setTimestamp()\n      return message.reply({ embeds: [devOnlyEmbed] })\n    }\n    try {\n      await command.executeMessage(message, args, client)\n    } catch (error) {\n      logger.error(`Error executing command: ${commandName}` + error)\n      console.log(error)\n      const eE = new EmbedBuilder()\n        .setColor(COLORS.red)\n        .setTitle('Opps!')\n        .setDescription(`${EMOJIS.failed} There was an error trying to run that command!`)\n      await message.reply({ embeds: [eE] })\n    }\n  })\n}\nAt this moment, you may get some errors because we haven't created our logger function yet! For\nthe logger function, please refer to the logging guide.\nAlright we have done, now let's go further!"}},"/developer/eventSetup/interactionCreate":{"title":"Interaction Create Event","data":{"":"The interactionCreate event in Discord.js is triggered whenever an interaction is created. This event is useful for handling various types of interactions such as slash commands, button clicks, and select menu selections. By listening to this event, you can execute specific code whenever a user interacts with your bot in these ways.","project-structure#Project Structure":"Now inside the client folder add our interactionCreate.ts file.","create-interactioncreatets#Create interactionCreate.ts":"Now, we have to write the logic for our interactionCreate event. This file will contain the logic that should be executed whenever a new interaction is created. Typically, you will check the type of interaction and then execute the corresponding action.\nThis interaction event handler comes with developer commands, bot permissions, and user permission\nchecks built-in.\nimport {\n  ChatInputCommandInteraction,\n  PermissionsBitField,\n  Interaction,\n  EmbedBuilder,\n  GuildMember,\n} from 'discord.js'\nimport { ExtendedClient } from '../../interfaces/ExtendedClient'\nimport { logger } from '../../utils/logger'\nimport config from '../../configs/botConfig'\nimport { COLORS, EMOJIS } from '../../constants/botConst'\nexport const eventHandlerInteraction = (client: ExtendedClient) => {\n  client.on('interactionCreate', async (interaction: Interaction) => {\n    if (!interaction.isCommand() || !interaction.guildId) return\n    const commandName = interaction.commandName\n    const command = client.slashCommands.get(commandName) // Use slashCommands collection\n    if (!command) {\n      logger.warn(`Command not found: ${commandName}`)\n      return\n    }\n    if (\n      command.userPermissions &&\n      !(interaction.member?.permissions as Readonly<PermissionsBitField>)?.has(\n        PermissionsBitField.resolve(command.userPermissions),\n      )\n    ) {\n      const userPermEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle('You cannot use this command!')\n        .setDescription(\n          `${EMOJIS.caution} You don't have the required permissions to use this commandz`,\n        )\n        .setTimestamp()\n      await interaction.reply({ embeds: [userPermEmbed], ephemeral: true })\n      return\n    }\n    const botMember = interaction.guild?.members.cache.get(client.user?.id || '') as GuildMember\n    if (\n      command.botPermissions &&\n      !botMember.permissions.has(PermissionsBitField.resolve(command.botPermissions))\n    ) {\n      const botPermEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle('I cannot use this command!')\n        .setDescription(\n          `${EMOJIS.caution} I don't have the required permissions to run this command`,\n        )\n        .setTimestamp()\n      await interaction.reply({ embeds: [botPermEmbed], ephemeral: true })\n      return\n    }\n    if (command.devOnly && !config.DEVELOPER_IDS.includes(interaction.user.id)) {\n      const devOnlyEmbed = new EmbedBuilder()\n        .setColor(COLORS.yellow)\n        .setTitle('You cannot use this command!')\n        .setDescription(`${EMOJIS.caution} This command is only for developers.`)\n        .setTimestamp()\n      await interaction.reply({ embeds: [devOnlyEmbed], ephemeral: true })\n      return\n    }\n    try {\n      await command.executeSlash(interaction as ChatInputCommandInteraction, client)\n    } catch (error) {\n      logger.error(`Error executing command: ${commandName} - ${error}`)\n      console.log(error)\n      const errorEmbed = new EmbedBuilder()\n        .setColor(COLORS.red)\n        .setTitle('Oops!')\n        .setDescription(`${EMOJIS.failed} There was an error trying to execute that command!`)\n        .setTimestamp()\n      await interaction.reply({ embeds: [errorEmbed], ephemeral: true })\n    }\n  })\n}\nYou can add more interactions, for example, context interactions and other Discord.js\ninteractions.\nDone, now let's go ahead!"}},"/developer/eventSetup/ready":{"title":"Ready Event","data":{"":"The ready event in Discord.js is a crucial event that signifies when the bot has successfully connected to Discord and is ready to start receiving and responding to events. This event is triggered once, immediately after the bot logs in and establishes a connection with Discord's servers.","project-structure#Project Structure":"First, create a folder named events inside the src folder. Then create a client folder inside the events folder and add a file named ready.ts.","create-readyts#Create ready.ts":"Now we will write the logic for the ready event.\nimport { logPastelPink } from 'nstypocolors'\nimport { ExtendedClient } from '../../interfaces/ExtendedClient'\nimport { ActivityType } from 'discord.js'\nimport { BOT } from '../../configs/metadata'\nexport const registerReadyEvent = (client: ExtendedClient) => {\n  client.once('ready', () => {\n    logPastelPink(`Successfully connected both Message & Slash clients ${client.user?.tag}!`)\n    client.user?.setPresence({\n      activities: [\n        {\n          name: `${BOT.PREFIX}help • ${client.user?.username}`,\n          type: ActivityType.Custom,\n        },\n      ],\n      status: 'online',\n    })\n  })\n}\nYou can customize this as you want. For more information, please visit the\nDiscord.js official\ndocumentation about the ready event and its types.","required-dependencies#Required Dependencies":"For this, you may have noticed that we have used the color library nstypocolors. Install nstypocolors via npm\nnpm i nstypocolors\nWe are highly suggested you to use nstypocolors only, dont use any other color libraries.\nAlright, we have done it! Now let's move ahead."}},"/developer/handlerSetup/cmd":{"title":"Command Handler","data":{"":"A command handler in a Discord bot is responsible for processing and executing commands received from users. It helps in organizing the command logic, making it easier to manage and extend. By using a command handler, you can separate the command definitions from the execution logic, ensuring that each command is handled appropriately based on the user's input.","project-structure#Project Structure":"Create a folder named handlers inside the src folder, and then create a file named commandHandler.ts.","create-commandhandlerts#Create commandHandler.ts":"This file will contain the logic of the command handler. It supports both message and interaction commands.\nimport { Collection } from 'discord.js'\nimport { readdirSync, statSync } from 'fs'\nimport { join } from 'path'\nimport { Command } from '../interfaces/Command'\nimport { ExtendedClient } from '../interfaces/ExtendedClient'\nimport { logger } from '../utils/logger'\nexport const commandHandler = (client: ExtendedClient) => {\n  client.slashCommands = new Collection()\n  client.messageCommands = new Collection()\n  const loadSlashCommands = (dir: string) => {\n    const files = readdirSync(dir)\n    for (const file of files) {\n      const filePath = join(dir, file)\n      const fileStat = statSync(filePath)\n      if (fileStat.isDirectory()) {\n        loadSlashCommands(filePath)\n      } else if (file.endsWith('.js') || file.endsWith('.ts')) {\n        const command: Command = require(filePath).default\n        if (typeof command.executeSlash === 'function') {\n          client.slashCommands.set(command.name, command)\n          logger.log(`Slash command loaded: ${command.name} from ${filePath}`)\n        }\n      }\n    }\n  }\n  const loadMessageCommands = (dir: string) => {\n    const files = readdirSync(dir)\n    for (const file of files) {\n      const filePath = join(dir, file)\n      const fileStat = statSync(filePath)\n      if (fileStat.isDirectory()) {\n        loadMessageCommands(filePath)\n      } else if (file.endsWith('.js') || file.endsWith('.ts')) {\n        const command: Command = require(filePath).default\n        if (typeof command.executeMessage === 'function') {\n          client.messageCommands.set(command.name, command)\n          logger.log(`Message command loaded: ${command.name} from ${filePath}`)\n        } else {\n          logger.error(\n            `Message command ${command.name} does not have executeMessage function defined`,\n          )\n        }\n      }\n    }\n  }\n  loadSlashCommands(join(__dirname, '../commands/slashCommands'))\n  loadMessageCommands(join(__dirname, '../commands/messageCommands'))\n  logger.sLog('All commands loaded')\n  client.slashCommands.forEach((command, name) => logger.log(`Loaded slash command: ${name}`))\n  client.messageCommands.forEach((command, name) => logger.log(`Loaded message command: ${name}`))\n}","verification#Verification":"Ensure that your commands are correctly imported from your command interface.\nAlright, now let's go further!"}},"/developer/utilSetup/logger":{"title":"Logger Function","data":{"":"A logger function is used to record various types of messages and events that occur during the execution of an application. This can include error messages, informational messages, warnings, and debugging information. The primary advantage of using a logger function is to provide an easy way to track and monitor the application's behavior and performance. It helps in debugging, analyzing issues, and maintaining the application more effectively.","project-structure#Project Structure":"First, create a folder named utils, and inside this folder, create a file named logger.ts.","creating-loggerts#Creating logger.ts":"Now, here is the logic for logger.ts:\nHighly suggested to use nstypocolors only!\nimport { logPastelGreen, logPastelLavender, logPastelRed, logPastelYellow } from 'nstypocolors'\nexport const logger = {\n  log: (message: string) => logPastelGreen(`[LOG] ${message}`),\n  sLog: (message: string) => logPastelLavender(`[SUCCESS] ${message}`),\n  warn: (message: string) => logPastelYellow(`[WARN] ${message}`),\n  error: (message: string) => logPastelRed(`[ERROR] ${message}`),\n}\nYou can add more logging functions like this to enhance your application's functionality.\nThat's it! Now go ahead."}}}